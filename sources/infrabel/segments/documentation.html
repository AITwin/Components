<!-- Embedded fragment: INFRABEL — Segments -->
<div id="infrabel-segments">
  <style>
    /* Scoped styles */
    #infrabel-segments { font-family: Inter, Arial, sans-serif; max-width: 980px; margin: 28px auto; line-height: 1.6; color: #222; padding: 0 16px; }
    #infrabel-segments h1,
    #infrabel-segments h2,
    #infrabel-segments h3 { color: #16324a; margin-top: 1.1rem; }
    #infrabel-segments code,
    #infrabel-segments pre { background: #f6f8fa; border-radius: 6px; }
    #infrabel-segments pre { padding: 12px; overflow: auto; }
    #infrabel-segments table { width: 100%; border-collapse: collapse; margin: 12px 0; }
    #infrabel-segments th,
    #infrabel-segments td { border: 1px solid #e1e4e8; padding: 8px; text-align: left; vertical-align: top; }
    #infrabel-segments th { background: #f3f6f9; }
    #infrabel-segments .muted { color:#566; font-size: 0.95rem; }
    #infrabel-segments ul { margin: 0.4rem 0 0.8rem 1.1rem; }
    #infrabel-segments .section { margin-bottom: 18px; }
  </style>

  <h1>INFRABEL — Segments</h1>
  <pre><code>GET /infrabel/segments</code></pre>
  <p class="muted">
    Returns geolocalized routes of all railway tracks on Belgium's Infrabel network, including main lines, secondary lines, sidings, and detailed track geometries.
  </p>

  <div class="section">
    <h2>Description</h2>
    <p>
      This endpoint provides comprehensive track-level geometry for Belgium's entire rail network, representing the physical routing of individual rail tracks (not just line-level abstractions like Line Sections).
      Each segment is a LineString geometry showing the precise geographic path of a track between two operational points (stations), including main tracks (primary revenue service), secondary tracks (branch lines, industrial spurs), and auxiliary tracks (sidings, yards, depot connections).
      Segments include detailed attribution: endpoint stations (by name and ID), track length (meters/kilometers), and representative coordinates (centroid for quick spatial queries without parsing full geometry).
      Unlike Line Sections (which provide logical infrastructure divisions with operational metadata like status/type), Segments offer detailed physical routing suitable for: precise network visualization (accurate map overlays), distance calculations (exact route lengths for journey planning), GPS-based train positioning (matching vehicle coordinates to track geometry), and infrastructure inventory (comprehensive track asset mapping).
      This dataset represents the most granular publicly available track geometry for Belgium's national rail network, essential for applications requiring meter-level spatial accuracy rather than schematic representations.
    </p>
  </div>

  <div class="section">
    <h2>Query Parameters</h2>
    <table>
      <tr><th>Parameter</th><th>Type</th><th>Required</th><th>Description</th></tr>
      <tr>
        <td><code>timestamp</code></td>
        <td>integer</td>
        <td>No</td>
        <td>Timestamp in seconds since epoch. If omitted, returns latest segment dataset (most recent track geometry configuration). If provided, returns dataset with timestamp ≤ specified value (less than or equal), enabling historical network geometry queries. Useful for analyzing infrastructure changes: new track construction (high-speed line additions, station expansions), track closures (line abandonment, temporary construction diversions), and geometry corrections (improved surveying, alignment updates). Historical queries support validation of past routing models, investigation of incidents on previous network configurations, and longitudinal studies of network evolution (visualizing decade-by-decade expansion or contraction).</td>
      </tr>
    </table>
  </div>

  <div class="section">
    <h2>Output Data Attributes</h2>
    <p>The response is a GeoJSON <code>FeatureCollection</code> representing track segments across Belgium's entire rail network.</p>
    <table>
      <tr><th>Attribute</th><th>Type</th><th>Description</th></tr>
      <tr><td>type</td><td>string</td><td>Always <code>FeatureCollection</code>. Standard GeoJSON container format ensuring compatibility with geospatial tools (QGIS, ArcGIS, PostGIS, GeoPandas), web mapping libraries (Leaflet, Mapbox GL JS, OpenLayers, Google Maps JavaScript API), and spatial databases. Collection represents Belgium's complete track network at segment level—finer granularity than Line Sections (operational divisions) but representing physical reality of individual rail tracks. Enables comprehensive network visualization (drawing every track on map with detailed geometry), precise spatial analysis (buffering tracks to identify nearby infrastructure, calculating exact distances along routes), and integration with GPS-based train tracking (matching vehicle positions to nearest track segment for display and analysis). Essential for applications requiring physical network accuracy rather than schematic abstractions.</td></tr>
      <tr><td>features</td><td>array</td><td>Array of track segment features, each representing one continuous rail track between two operational points. Typical size: 10,000-30,000+ segments covering Belgium's dense rail network (~3600 km main lines plus thousands of km of secondary tracks, sidings, yards, depot connections, and specialized tracks). Feature count exceeds Line Sections count by order of magnitude because: (1) Segments include all tracks (main lines, branches, sidings) while Line Sections focus on primary operational routes, (2) Segments represent individual physical tracks (separate features for parallel tracks in double/triple-track sections) while Line Sections may group multiple tracks, (3) Segments include fine subdivisions (junctions split into multiple short segments, complex station throat geometries broken into constituent tracks). Each feature is a graph edge connecting two operational point nodes, collectively forming detailed network topology for routing algorithms. Array includes: (a) Main line segments (high-speed lines, intercity corridors with precise alignment geometry), (b) Regional line segments (secondary routes, branch lines), (c) Yard tracks (marshaling, maintenance facilities), (d) Station tracks (platform tracks, crossovers, turnouts within station complexes), (e) Industrial sidings (factory connections, port tracks). Segment granularity means some operational points have dozens of connecting segments (major junctions like Brussels South, Antwerp Central with complex track layouts), while minor stations may have just 2 segments (single through-track). Used for: (1) High-fidelity network mapping (showing every track, not just main lines), (2) GPS train positioning (mapping vehicle coordinates to specific track using spatial proximity), (3) Infrastructure inventory (complete track asset database for maintenance planning), (4) Capacity modeling (detailed topology for simulating train movements through junctions, stations), (5) Routing algorithms (building graph with realistic track constraints—single vs. double track, junction configurations). Data completeness varies: main lines have high-quality surveyed geometry, minor tracks may have simplified or estimated alignments.</td></tr>
      <tr><td>features[].type</td><td>string</td><td>Always <code>Feature</code>. Standard GeoJSON object type for individual spatial entities. Each feature represents one track segment with its geographic routing (geometry) and descriptive attributes (properties). Consistent structure enables standard GIS workflows: spatial queries (which segments intersect this polygon?), attribute filtering (segments longer than 10 km), thematic mapping (color segments by length, by station endpoints), and spatial joins (linking segments to other geographic datasets like municipalities, terrain elevation). Essential for GeoJSON specification compliance and interoperability across diverse platforms and tools.</td></tr>
      <tr><td>features[].geometry</td><td>object</td><td>GeoJSON LineString geometry representing track's physical routing as sequence of coordinate pairs forming continuous line from origin to destination operational point. Geometry reflects surveyed or estimated track centerline (alignment midpoint between rails), suitable for mapping, distance calculations, and spatial analysis. Vertex density (coordinates per km) varies: straight sections may have few points (start/end plus occasional intermediate), curved sections have denser vertices to accurately represent curvature without excessive point count. Precision typically 5-6 decimal places (~1-10 meter accuracy), balancing spatial fidelity with data payload size. Used for: (1) Map rendering (drawing track network overlays on base maps), (2) GPS matching (finding nearest segment to vehicle position for positioning systems), (3) Distance calculations (measuring exact route length using cumulative segment distances along path), (4) Spatial analysis (buffering tracks for noise impact zones, proximity queries for nearby infrastructure). Important: Geometry represents schematic/planning-grade alignment, not engineering-grade centerline—sufficient for visualization and analysis but not for construction design, signal placement, or centimeter-precision GPS positioning (which require specialized surveying data from Infrabel's engineering systems, not public datasets).</td></tr>
      <tr><td>geometry.type</td><td>string</td><td>Always <code>LineString</code>. GeoJSON geometry type for one-dimensional linear features representing track alignments. LineString (sequence of connected points forming continuous line) is natural representation for rail tracks: start point (origin station), intermediate vertices (curves, alignment changes), end point (destination station). Simpler than MultiLineString (used when single logical segment has disconnected parts, rare for rail tracks which are continuous), more specific than generic Geometry (which could be any type). LineString enables: (1) Standard line-based GIS operations (length calculation, buffering, simplification), (2) Route following algorithms (traversing coordinates in order), (3) Efficient spatial indexing (R-tree structures for fast proximity queries), (4) Straightforward visualization (drawing paths on maps). All standard mapping libraries have optimized LineString rendering.</td></tr>
      <tr><td>geometry.coordinates</td><td>array</td><td>Nested array of coordinate pairs <code>[[lon1, lat1], [lon2, lat2], ..., [lonN, latN]]</code> defining track path in WGS84 (EPSG:4326) decimal degrees. Belgium bounds: longitude 2.5-6.4°E, latitude 49.5-51.5°N. Array length (N = number of vertices) varies by segment length and geometry complexity: short straight segments may have just 2 points (start and end), long curved segments have dozens to hundreds of points capturing alignment details. Order follows track direction from origin station to destination station (generally, though direction may be ambiguous for bidirectional tracks). Coordinate precision typically 5-7 decimal places providing ~1-10 meter accuracy. Used directly by mapping libraries (Leaflet L.polyline(coords), Mapbox addSource) for rendering, by routing engines for pathfinding, and by spatial algorithms for distance/proximity calculations. Example segment: <code>[[4.3517, 50.8466], [4.3625, 50.8512], [4.3798, 50.8601]]</code> representing track from Brussels Central northward with intermediate curve vertex. Coordinates suitable for: (1) Visualization (map overlays), (2) Distance calculation (Haversine or great-circle formulas between consecutive points, summed for total segment length), (3) GPS positioning (finding closest coordinate to vehicle location), (4) Spatial queries (does segment intersect bounding box, cross municipality boundary). Not suitable for engineering applications requiring millimeter precision (track gauge measurements, cant calculations, signal placement), which need specialized high-precision geodetic data.</td></tr>
      <tr><td>properties.stationfrom_id</td><td>string</td><td>Identifier of origin operational point (station) where this track segment begins. Typically matches <code>ptcarid</code> from Operational Points dataset, enabling joins to obtain origin station details: name (Dutch/French), coordinates (lat/lon), classification (passenger station, junction, etc.). Format is Infrabel operational point code (alphanumeric, 4-8 characters like "BXLCE" for Brussels Central, "ANR" for Antwerp). Used for: (1) Building network graph topology (segments as directed edges, stationfrom_id as source node), (2) Filtering segments by origin ("all segments departing Brussels Central"), (3) Routing algorithms (determining valid transitions from one segment to next based on station connectivity), (4) Joining with station metadata (displaying origin station names on maps, querying station attributes). Essential for converting geometric segment collection into topological network—segments alone are disconnected LineStrings, station IDs provide connectivity. Note: "from" direction may be conventional (not necessarily indicating primary traffic flow direction for bidirectional tracks), but consistent within dataset enabling reliable graph construction.</td></tr>
      <tr><td>properties.stationfrom_name</td><td>string</td><td>Human-readable name of origin operational point, typically in Dutch (Infrabel's default system language). Examples: "Brussel-Centraal" (Brussels Central), "Antwerpen-Centraal" (Antwerp Central), "Luik-Guillemins" (Liège-Guillemins). Matches or closely corresponds to <code>longnamedutch</code> or <code>shortnamedutch</code> from Operational Points, though minor spelling variations may exist. Used for: (1) User-facing displays (showing origin station names on segment popups/labels rather than cryptic IDs), (2) Data exploration (filtering by familiar station names: "show segments from Gent-Sint-Pieters"), (3) Quality validation (ensuring name-ID consistency, detecting data errors), (4) Bilingual applications (join with Operational Points to get French equivalent for French-speaking users). Name provides human-readable context but station ID (stationfrom_id) should be used for programmatic joins (names may have spelling inconsistencies, IDs are stable).</td></tr>
      <tr><td>properties.stationto_id</td><td>string</td><td>Identifier of destination operational point (station) where this track segment ends. Parallel to stationfrom_id, representing segment's terminal node in network graph. Format same as stationfrom_id (ptcarid-style code). Used for: (1) Graph edge definition (segments connect stationfrom_id → stationto_id), (2) Routing algorithms (determining reachable destinations from current segment), (3) Filtering segments by destination, (4) Joining with Operational Points for destination station details. Together, stationfrom_id and stationto_id define segment's topological role: edge in directed graph connecting two nodes. Essential for pathfinding: shortest-path algorithms traverse graph by following stationto_id of one segment to find connected segments with matching stationfrom_id, building multi-segment routes. Note: Bidirectional tracks require reciprocal segment pairs (one segment from A to B, another from B to A) to represent both travel directions in directed graph models.</td></tr>
      <tr><td>properties.stationto_name</td><td>string</td><td>Human-readable name of destination operational point, paralleling stationfrom_name. Provides destination context for user-facing applications (segment labels: "Brussels Central → Antwerp Central"). Used for readable displays, data exploration, and validation. Join with Operational Points using stationto_id for multilingual names and complete station metadata. Together, stationfrom_name and stationto_name provide human-readable segment description, essential for debugging topology (visually verifying segment connections), generating reports ("top 10 busiest segments by traffic volume"), and user interfaces (showing segments in human-readable format).</td></tr>
      <tr><td>properties.length</td><td>number</td><td>Segment length in meters (or possibly kilometers—check dataset documentation or typical value ranges to confirm units). Represents physical track distance from origin to destination operational point, calculated from geometry coordinates using appropriate geodesic formulas (accounting for Earth's curvature). Typical main line segment lengths: 2,000-10,000 meters (2-10 km) between major stations, though range varies: short segments in dense urban areas (500-1000m between frequent stations), very long segments in rural areas (15+ km between sparse stations), extremely short segments at junctions (10-100m for complex turnout/crossover tracks). Used for: (1) Journey distance calculations (summing segment lengths along multi-segment route for total trip distance), (2) Infrastructure inventory (total track kilometers for asset valuation, maintenance budgeting: sum all segment lengths), (3) Performance analysis (speed calculations: distance/time for trains traversing segment), (4) Capacity modeling (longer segments allow higher speeds but less granular capacity allocation, shorter segments enable tighter train spacing but more signaling complexity). Length enables analyses without recalculating from geometry coordinates (precomputed for convenience). Validate units by checking typical values: if most segments show 2000-10000, likely meters; if 2-10, likely kilometers. Unit ambiguity is common in infrastructure datasets—always verify before calculations!</td></tr>
      <tr><td>properties.geo_point_2d</td><td>object</td><td>Representative geographic point for the segment, typically centroid (midpoint) of LineString geometry. Object contains <code>lat</code> (latitude) and <code>lon</code> (longitude) in WGS84 decimal degrees. Used for: (1) Quick distance calculations without parsing full geometry ("segments within 50 km of Brussels" using centroid distance as approximation before detailed geometry analysis), (2) Map marker placement (annotating segments with icons, labels, or popup info at representative central location rather than start/end), (3) Spatial indexing (R-tree or geohash indexing on centroids for fast proximity queries: "find nearby segments" without comparing to every geometry vertex), (4) Simplified visualizations (showing segments as points on overview maps before zooming to detailed LineString view). Centroid is approximate segment location—sufficient for many analytical purposes and much faster than geometry-based operations. Not suitable for precise applications: train at segment centroid doesn't imply train is physically at that exact coordinate (could be anywhere along segment). For precise positioning, match GPS coordinates to nearest geometry vertex, not centroid. Centroid calculation may use simple averaging (mean of all coordinates) or geometric centroid algorithms (accounting for non-uniform vertex spacing); check dataset documentation if distinction matters for analysis.</td></tr>
    </table>

    <p style="margin-top: 1.5em; padding: 0.75em; background: #f8f9fa; border-left: 3px solid #28a745; font-size: 0.95em;">
      <strong>Operational Context:</strong> Segments dataset represents Belgium's rail network at physical track level, providing the most detailed publicly-available infrastructure geometry suitable for precision mapping and analysis. 
      <em>For visualization applications</em>, segments enable high-fidelity network maps: rendering every track (main lines, branches, yards) with accurate geographic routing, creating realistic transit maps for planning and information, and overlaying infrastructure on base maps (OpenStreetMap, Google Maps) for context. 
      <em>For GPS-based train tracking</em>, segments provide geometric reference for map-matching algorithms: comparing vehicle GPS coordinates to segment geometries, snapping positions to nearest track for clean display (avoiding "off-track" appearance from GPS error), and determining which track vehicle occupies in multi-track sections (critical for accurate visualizations). 
      <em>For distance calculations</em>, segments enable precise journey length measurement: summing segment lengths along route for total trip distance (more accurate than great-circle calculations which ignore actual track routing), calculating remaining distance to destination for ETA predictions, and measuring infrastructure extents for asset management (total track kilometers by region, by line, by track type). 
      <em>For routing algorithms</em>, segments form detailed graph structure: nodes = operational points, edges = segments with length attributes, enabling shortest-path calculations accounting for actual track topology (not just straight-line distances), and supporting constrained routing (avoiding specific segments for maintenance, modeling track availability). 
      <em>For infrastructure planning</em>, segments support: (1) Capacity analysis (identifying single-track bottlenecks limiting traffic, prioritizing double-tracking investments), (2) Maintenance planning (tracking kilometers by segment attributes for resurfacing programs, electrification projects), (3) Expansion studies (modeling new segments, testing connectivity impacts), (4) Asset valuation (total track length as infrastructure value proxy). 
      <em>For spatial analysis</em>, segment geometries enable: (1) Noise impact modeling (buffering tracks to identify residential areas within noise zones, informing sound barrier placement), (2) Accessibility studies (calculating population within X km of tracks for potential station location analysis), (3) Environmental impact assessment (measuring track lengths through protected areas, wetlands), (4) Multi-modal integration (identifying road-rail crossings by intersecting segment geometries with road network data). 
      The detailed granularity (10,000-30,000 segments vs. ~500-1000 line sections) provides precision but requires more processing: rendering 30,000 LineStrings may challenge web mapping performance (use zoom-based filtering, simplification), graph algorithms on 30K-edge networks need optimization (indexing, A* heuristics), and data payloads are larger (multi-MB responses require compression, pagination). 
      Comparison with Line Sections: Segments provide physical routing (where tracks actually go, with real geometry), Line Sections provide operational metadata (status, type, characteristics). Both are complementary—use Segments for geometry-driven applications (mapping, positioning, distance), Line Sections for attribute-driven analysis (capacity, status, classifications). Joining both datasets (via station IDs or spatial proximity) combines geometric precision with operational context.
    </p>
  </div>

  <div class="section">
    <h2>Estimated Response Volume</h2>
    <ul>
      <li>Observed dataset stability: ~404 updates between 2024-08-21 and 2025-10-23 (approximately daily updates)</li>
      <li>Typical response: 10,000-30,000 segment features covering Belgium's entire rail network</li>
      <li>Response size: Large (10-50+ MB) due to detailed geometry (thousands of coordinate pairs per segment × thousands of segments)</li>
      <li>Recommendation: For web applications, implement zoom-based filtering (load only segments visible in viewport), geometry simplification (reduce coordinate density for overview zoom levels), or server-side pre-processing (tile-based delivery, vector tiles for efficient streaming)</li>
    </ul>
  </div>

  <div class="section">
    <h2>Data Source &amp; Transformation Pipeline</h2>
    <h3>Data Source</h3>
    <ul>
      <li>Infrabel infrastructure database containing surveyed track geometries, derived from: (1) GPS surveys (modern high-precision methods), (2) Historical engineering plans (digitized for older infrastructure), (3) Photogrammetry/LiDAR (aerial/drone surveys for alignment verification)</li>
      <li>Published to <a href="https://opendata.infrabel.be" target="_blank" style="color: #0366d6;">opendata.infrabel.be</a> after geometry processing and validation</li>
      <li>Updated regularly (approximately daily) to reflect new track construction, closures, and geometry corrections</li>
    </ul>

    <h3>Transformation Pipeline</h3>
    <ol>
      <li><strong>Geometry Extraction:</strong> Retrieve track centerline geometries from Infrabel GIS databases, typically stored in engineering coordinate systems (Belgian Lambert or custom), convert to WGS84 for global compatibility</li>
      <li><strong>Segmentation:</strong> Divide continuous track alignments into segments at operational point boundaries (stations), creating graph edge structure with defined start/end nodes</li>
      <li><strong>Simplification:</strong> Apply Douglas-Peucker or similar algorithms to reduce coordinate count while preserving alignment shape (balancing geometry fidelity with file size), target precision appropriate for public data (1-10m accuracy sufficient for most applications)</li>
      <li><strong>Attribute Association:</strong> Link each segment to origin/destination station IDs and names via topological analysis, calculate segment lengths from coordinate sequences using geodesic formulas, compute centroids for representative points</li>
      <li><strong>Quality Validation:</strong> Check topology (all segments connect to valid stations, no dangling ends unless terminal tracks), validate geometries (no self-intersections, coordinate bounds within Belgium), verify attribute consistency (station IDs exist in Operational Points dataset)</li>
      <li><strong>Formatting:</strong> Structure as GeoJSON FeatureCollection with standardized properties, add metadata headers (timestamp, version), compress (gzip) for delivery</li>
    </ol>
  </div>

  <div class="section">
    <h2>Example Application Scenarios</h2>
    <ul>
      <li><strong>High-Fidelity Network Mapping:</strong> Render every track segment on interactive map with realistic routing (not schematic diagrams), color-code by length or station connections, enable click-for-details (segment attributes in popup), support zoom-dependent simplification (detailed geometry at close zoom, simplified at overview)</li>
      <li><strong>GPS Train Positioning:</strong> Collect real-time train GPS coordinates from SNCB vehicle-position API, match to nearest segment using spatial proximity (PostGIS ST_Distance, Python shapely), snap position to segment geometry for clean map display, display train icon along segment LineString with interpolated position</li>
      <li><strong>Journey Distance Calculator:</strong> Build routing graph (segments as edges, stations as nodes), compute shortest path between origin/destination using Dijkstra algorithm with segment lengths as weights, sum segment lengths along path for total trip distance (more accurate than great-circle), display route on map with segment highlighting</li>
      <li><strong>Infrastructure Inventory Dashboard:</strong> Calculate total track length (sum all segment lengths), aggregate by region (sum segments within municipality/province polygons via spatial join), breakdown by track type (main vs. secondary vs. yard—if classification available), generate reports for asset valuation, maintenance budgeting</li>
      <li><strong>Noise Impact Modeling:</strong> Buffer all segment geometries by 500m/1000m (typical noise impact distances), intersect buffers with residential building polygons or population grid cells, identify affected population, prioritize noise barrier installation for segments with highest impacted population density</li>
      <li><strong>Capacity Bottleneck Analysis:</strong> Join segments with Line Sections to add operational metadata (single vs. double track), filter single-track segments (bottlenecks limiting bidirectional traffic), sort by length (longer single-track sections = worse bottlenecks), map for visual identification, prioritize for double-tracking investments</li>
      <li><strong>Multi-Modal Integration:</strong> Spatially intersect segment geometries with road network data (OpenStreetMap), identify road-rail grade crossings (intersection points), buffer crossings to find nearby stations for park-and-ride analysis, calculate population within 2km of crossing for station demand forecasting</li>
    </ul>
  </div>

  <div class="section">
    <h2>Important Notes</h2>
    <ul>
      <li><strong>Large Dataset:</strong> 10,000-30,000 features with detailed geometries create multi-MB responses. Implement efficient loading: spatial filtering (bounding box queries), zoom-level filtering (load only visible segments), vector tiles (MVT format for streaming), or pre-processed subsets (main lines only for overview maps).</li>
      <li><strong>Geometry Precision:</strong> Coordinates are planning-grade (1-10m accuracy), not engineering-grade (centimeter precision). Suitable for mapping, analysis, and general positioning, but not for construction design, signal placement, or safety-critical applications requiring survey-grade data.</li>
      <li><strong>Units Clarification:</strong> Verify <code>length</code> property units (meters vs. kilometers) by checking typical value ranges before calculations. Dataset documentation may specify, or infer from data (values 2000-10000 suggest meters, 2-10 suggest kilometers).</li>
      <li><strong>Topology Dependency:</strong> Segments must be combined with Operational Points dataset for complete network topology. Segment IDs (stationfrom_id, stationto_id) reference Operational Points for node coordinates, names, and attributes—incomplete without joining both datasets.</li>
      <li><strong>Bidirectional Representation:</strong> Check if dataset includes reciprocal segments for bidirectional tracks (separate features for A→B and B→A) or single segments intended as undirected edges. Affects routing algorithm design—directed graphs need explicit reverse edges, undirected graphs can traverse either direction on single segment.</li>
    </ul>
  </div>
</div>
